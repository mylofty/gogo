import comp from "/Users/jimmy/workspace/gogo/vuepress/docs/.vuepress/.temp/pages/posts/GMP原理.html.vue"
const data = JSON.parse("{\"path\":\"/posts/GMP%E5%8E%9F%E7%90%86.html\",\"title\":\"\",\"lang\":\"zh-cn\",\"frontmatter\":{\"date\":\"2023-03-05T00:00:00.000Z\",\"category\":[\"Go\",\"CategoryB\"],\"tag\":[\"Go\"]},\"headers\":[{\"level\":2,\"title\":\"2.4 GMP源码剖析\",\"slug\":\"_2-4-gmp源码剖析\",\"link\":\"#_2-4-gmp源码剖析\",\"children\":[{\"level\":3,\"title\":\"2.4.1 协程G结构体\",\"slug\":\"_2-4-1-协程g结构体\",\"link\":\"#_2-4-1-协程g结构体\",\"children\":[]},{\"level\":3,\"title\":\"2.4.2 线程M结构体\",\"slug\":\"_2-4-2-线程m结构体\",\"link\":\"#_2-4-2-线程m结构体\",\"children\":[]},{\"level\":3,\"title\":\"2.4.3 处理器P结构体\",\"slug\":\"_2-4-3-处理器p结构体\",\"link\":\"#_2-4-3-处理器p结构体\",\"children\":[]},{\"level\":3,\"title\":\"2.4.5 协程G的创建过程\",\"slug\":\"_2-4-5-协程g的创建过程\",\"link\":\"#_2-4-5-协程g的创建过程\",\"children\":[]},{\"level\":3,\"title\":\"2.4.6 协程G的退出过程\",\"slug\":\"_2-4-6-协程g的退出过程\",\"link\":\"#_2-4-6-协程g的退出过程\",\"children\":[]},{\"level\":3,\"title\":\"2.4.7 协程G的切换过程\",\"slug\":\"_2-4-7-协程g的切换过程\",\"link\":\"#_2-4-7-协程g的切换过程\",\"children\":[]},{\"level\":3,\"title\":\"2.4.8 协程G的栈内存分配\",\"slug\":\"_2-4-8-协程g的栈内存分配\",\"link\":\"#_2-4-8-协程g的栈内存分配\",\"children\":[]},{\"level\":3,\"title\":\"2.4.9 处理器P的创建过程\",\"slug\":\"_2-4-9-处理器p的创建过程\",\"link\":\"#_2-4-9-处理器p的创建过程\",\"children\":[]},{\"level\":3,\"title\":\"2.4.9 线程M的创建过程\",\"slug\":\"_2-4-9-线程m的创建过程\",\"link\":\"#_2-4-9-线程m的创建过程\",\"children\":[]},{\"level\":3,\"title\":\"2.4.10 线程M的启动过程\",\"slug\":\"_2-4-10-线程m的启动过程\",\"link\":\"#_2-4-10-线程m的启动过程\",\"children\":[]}]},{\"level\":2,\"title\":\"2.5 调度器源码分析\",\"slug\":\"_2-5-调度器源码分析\",\"link\":\"#_2-5-调度器源码分析\",\"children\":[{\"level\":3,\"title\":\"2.5.1 系统全局变量\",\"slug\":\"_2-5-1-系统全局变量\",\"link\":\"#_2-5-1-系统全局变量\",\"children\":[]},{\"level\":3,\"title\":\"2.5.2 调度器schedt结构体\",\"slug\":\"_2-5-2-调度器schedt结构体\",\"link\":\"#_2-5-2-调度器schedt结构体\",\"children\":[]},{\"level\":3,\"title\":\"2.5.3 调度器初始化\",\"slug\":\"_2-5-3-调度器初始化\",\"link\":\"#_2-5-3-调度器初始化\",\"children\":[]},{\"level\":3,\"title\":\"2.5.4 调度器启动调度流程\",\"slug\":\"_2-5-4-调度器启动调度流程\",\"link\":\"#_2-5-4-调度器启动调度流程\",\"children\":[]},{\"level\":3,\"title\":\"2.5.5 调度器调度流程\",\"slug\":\"_2-5-5-调度器调度流程\",\"link\":\"#_2-5-5-调度器调度流程\",\"children\":[]},{\"level\":3,\"title\":\"2.5.6 协程调度策略\",\"slug\":\"_2-5-6-协程调度策略\",\"link\":\"#_2-5-6-协程调度策略\",\"children\":[]}]}],\"git\":{\"updatedTime\":null,\"contributors\":[]},\"filePathRelative\":\"posts/GMP原理.md\",\"excerpt\":\"<h2>2.4 GMP源码剖析</h2>\\n<h3>2.4.1 协程G结构体</h3>\\n<div class=\\\"language-go\\\" data-ext=\\\"go\\\" data-title=\\\"go\\\"><pre class=\\\"language-go\\\"><code><span class=\\\"token comment\\\">// src/runtime/runtime2.go</span>\\n\\n\\n<span class=\\\"token keyword\\\">type</span> g <span class=\\\"token keyword\\\">struct</span> <span class=\\\"token punctuation\\\">{</span>\\n    stack       stack   <span class=\\\"token comment\\\">// 保存当前协程栈的上界和下界</span>\\n    <span class=\\\"token comment\\\">// stackguard0 是对比 Go 栈增长的 prologue 的栈指针</span>\\n    <span class=\\\"token comment\\\">// 如果 sp 寄存器比 stackguard0 小（由于栈往低地址方向增长），会触发栈拷贝和调度</span>\\n    <span class=\\\"token comment\\\">// 通常情况下：stackguard0 = stack.lo + StackGuard，但被抢占时会变为 StackPreempt</span>\\n    stackguard0 <span class=\\\"token builtin\\\">uintptr</span> <span class=\\\"token comment\\\">// offset known to liblink</span>\\n    <span class=\\\"token comment\\\">// stackguard1 是对比 C 栈增长的 prologue 的栈指针</span>\\n    <span class=\\\"token comment\\\">// 当位于 g0 和 gsignal 栈上时，值为 stack.lo + StackGuard</span>\\n    <span class=\\\"token comment\\\">// 在其他栈上值为 ~0 用于触发 morestackc (并 crash) 调用</span>\\n    stackguard1 <span class=\\\"token builtin\\\">uintptr</span> <span class=\\\"token comment\\\">// offset known to liblink</span>\\n    _panic    <span class=\\\"token operator\\\">*</span>_panic   <span class=\\\"token comment\\\">// 这个协程里面的panic列表</span>\\n    _defer    <span class=\\\"token operator\\\">*</span>_defer   <span class=\\\"token comment\\\">// 这个协程里面的defer列表</span>\\n    m           <span class=\\\"token operator\\\">*</span>m      <span class=\\\"token comment\\\">// 当前g占用的线程m</span>\\n    sched       gobuf   <span class=\\\"token comment\\\">// 协程调度的上下文数据 保存PC，SP等寄存器，协程切换的参数，描述了执行现场</span>\\n    atomicstatus atomic<span class=\\\"token punctuation\\\">.</span>Uint32 <span class=\\\"token comment\\\">// G 的状态</span>\\n    syscallsp   <span class=\\\"token builtin\\\">uintptr</span> <span class=\\\"token comment\\\">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span>\\n    syscallpc   <span class=\\\"token builtin\\\">uintptr</span> <span class=\\\"token comment\\\">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span>\\n    stktopsp    <span class=\\\"token builtin\\\">uintptr</span> <span class=\\\"token comment\\\">// expected sp at top of stack, to check in traceback</span>\\n    goid        <span class=\\\"token builtin\\\">uint64</span>  <span class=\\\"token comment\\\">// 协程唯一id？</span>\\n    preempt     <span class=\\\"token builtin\\\">bool</span>    <span class=\\\"token comment\\\">// 是否可以抢占 preemption signal, duplicates stackguard0 = stackpreempt</span>\\n    preemptStop   <span class=\\\"token builtin\\\">bool</span> <span class=\\\"token comment\\\">// transition to _Gpreempted on preemption; otherwise, just deschedule</span>\\n    preemptShrink <span class=\\\"token builtin\\\">bool</span> <span class=\\\"token comment\\\">// shrink stack at synchronous safe point</span>\\n    <span class=\\\"token operator\\\">...</span>\\n</code></pre></div>\"}")
export { comp, data }

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
